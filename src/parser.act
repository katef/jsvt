/*
 * Copyright 2017 Katherine Flavel
 *
 * See LICENCE for the full copyright terms.
 */

%prefixes%

	terminal = JSON_;
	function = p_;

%persistents%

	lex_state :lex_state;
	act_state :act_state;
	ast       :ast;

%maps%

	string -> string;
	number -> number;
	bool   -> int;

	kw     -> kw;
	type   -> type;

%header% @{

	#define _POSIX_C_SOURCE 200809L

	#include <assert.h>
	#include <stdlib.h>
	#include <string.h>

	#include "json.h"
	#include "parser.h"
	#include "jdom.h"
	#include "ast.h"
	#include "kw.h"

	struct act_state {
		enum json_type t;
		enum json_type save;
	};

	typedef struct json_string string;
	typedef json_number number;
	typedef enum lxkw_token kw;
	typedef enum json_valuetype type;

	#define true  1
	#define false 0

	#define JSON_ARRAY__END  JSON_ARRAY_END
	#define JSON_OBJECT__END JSON_OBJECT_END

	#define CURRENT_TERMINAL act_state->t
	#define ERROR_TERMINAL   JSON_ERROR
	#define ADVANCE_LEXER    act_state->t = json_next(lex_state)
	#define SAVE_LEXER(t)    act_state->save = (t)
	#define RESTORE_LEXER    act_state->t = act_state->save

	/* TODO: move to kw.c */
	static enum lxkw_token
	kw_lookup(const struct json_string *str)
	{
		struct lxkw_lx lx = { 0 };
		struct lx_arr a;
		enum lxkw_token k, e;

		assert(str != NULL);
		assert(str->s != NULL);
		assert(str->len >= 1);

/* XXX: lx_arr.p ought to be const */
		a.p   = str->s;
		a.len = str->len - 1;

		lxkw_init(&lx);

		lx.lgetc  = lxkw_agetc;
		lx.opaque = &a;

		k = lxkw_next(&lx);
		switch (k) {
		case LXKW_ERROR:
		case LXKW_EOF:
		case LXKW_UNKNOWN:
			return k;

		default:
			break;
		}

		e = lxkw_next(&lx);
		if (e != LXKW_EOF) {
			return e;
		}

		return k;
	}

	/* TODO: move to jdom.c */
	enum json_valuetype
	type_lookup(const struct json_string *str)
	{
		size_t i;

		struct {
			enum json_valuetype t;
			const char *s;
		} a[] = {
			{ JSON_VALUE_OBJECT,  "object"  },
			{ JSON_VALUE_ARRAY,   "array"   },
			{ JSON_VALUE_STRING,  "string"  },
			{ JSON_VALUE_NUMBER,  "number"  },
			{ JSON_VALUE_INTEGER, "integer" },
			{ JSON_VALUE_BOOL,    "boolean" },
			{ JSON_VAlUE_NULL,    "null"    },
			{ ~0U,                "any"     }
		};

		assert(str != NULL);
		assert(str->s != NULL);

		for (i = 0; i < sizeof a / sizeof *a; i++) {
			/* TODO: json_strcmp() */
			if (str->len != strlen(a[i].s) + 1) {
				continue;
			}

			if (0 == strcmp(str->s, a[i].s)) {
				return a[i].t;
			}
		}

		return 0;
	}

	char *
	xstrndup(const char *s, size_t n)
	{
		char *new;

		new = strndup(s, n);
		if (new == NULL) {
			perror("xstrndup");
			abort();
		}

		return new;
	}

@}, @{

	#include <stdio.h>

	#include "json.h"

	typedef struct ast_schema * ast;
	typedef struct act_state * act_state;
	typedef json_stream * lex_state;

@};

%terminals%

	STRING: () -> (s :string) = @{
		assert(act_state->t == JSON_STRING);

		@s.s = json_get_string(lex_state, &@s.len);
		if (@s.s == NULL) {
			perror("json_get_string");
			exit(1);
		}

		@s.s = xstrndup(@s.s, @s.len);
	@};

	NUMBER: () -> (n :number) = @{
		assert(act_state->t == JSON_NUMBER);

		@n = json_get_number(lex_state);
	@};

	TRUE: () -> (v :bool) = @{
		@v = true;
	@};

	FALSE: () -> (v :bool) = @{
		@v = false;
	@};

%actions%

	<kw-lookup>: (s :string) -> (k :kw) = @{
		@k = kw_lookup(&@s);
		if (@k == LXKW_ERROR) {
			/* TODO: perror? */
			exit(EXIT_FAILURE);
		}

		if (@k == LXKW_UNKNOWN) {
			@!;
		}
	@};

	<type-lookup>: (s :string) -> (t :type) = @{
		@t = type_lookup(&@s);
		if (@t == 0) {
			fprintf(stderr, "Unknown type name: \"%s\"\n", @s.s);
			@!;
		}
	@};

	<kw-schema>:               (k :kw) -> (v :bool) = @{ @v = (@k == LXKW_SCHEMA);               @};
	<kw-ref>:                  (k :kw) -> (v :bool) = @{ @v = (@k == LXKW_REF);                  @};
	<kw-id>:                   (k :kw) -> (v :bool) = @{ @v = (@k == LXKW_ID);                   @};

	<kw-multipleof>:           (k :kw) -> (v :bool) = @{ @v = (@k == LXKW_MULTIPLEOF);           @};
	<kw-maximum>:              (k :kw) -> (v :bool) = @{ @v = (@k == LXKW_MAXIMUM);              @};
	<kw-exclusivemaximum>:     (k :kw) -> (v :bool) = @{ @v = (@k == LXKW_EXCLUSIVEMAXIMUM);     @};
	<kw-minimum>:              (k :kw) -> (v :bool) = @{ @v = (@k == LXKW_MINIMUM);              @};
	<kw-exclusiveminimum>:     (k :kw) -> (v :bool) = @{ @v = (@k == LXKW_EXCLUSIVEMINIMUM);     @};
	<kw-maxlength>:            (k :kw) -> (v :bool) = @{ @v = (@k == LXKW_MAXLENGTH);            @};
	<kw-minlength>:            (k :kw) -> (v :bool) = @{ @v = (@k == LXKW_MINLENGTH);            @};
	<kw-pattern>:              (k :kw) -> (v :bool) = @{ @v = (@k == LXKW_PATTERN);              @};
	<kw-items>:                (k :kw) -> (v :bool) = @{ @v = (@k == LXKW_ITEMS);                @};
	<kw-additionalitems>:      (k :kw) -> (v :bool) = @{ @v = (@k == LXKW_ADDITIONALITEMS);      @};
	<kw-maxitems>:             (k :kw) -> (v :bool) = @{ @v = (@k == LXKW_MAXITEMS);             @};
	<kw-minitems>:             (k :kw) -> (v :bool) = @{ @v = (@k == LXKW_MINITEMS);             @};
	<kw-uniqueitems>:          (k :kw) -> (v :bool) = @{ @v = (@k == LXKW_UNIQUEITEMS);          @};
	<kw-contains>:             (k :kw) -> (v :bool) = @{ @v = (@k == LXKW_CONTAINS);             @};
	<kw-maxproperties>:        (k :kw) -> (v :bool) = @{ @v = (@k == LXKW_MAXPROPERTIES);        @};
	<kw-minproperties>:        (k :kw) -> (v :bool) = @{ @v = (@k == LXKW_MINPROPERTIES);        @};
	<kw-required>:             (k :kw) -> (v :bool) = @{ @v = (@k == LXKW_REQUIRED);             @};
	<kw-properties>:           (k :kw) -> (v :bool) = @{ @v = (@k == LXKW_PROPERTIES);           @};
	<kw-patternproperties>:    (k :kw) -> (v :bool) = @{ @v = (@k == LXKW_PATTERNPROPERTIES);    @};
	<kw-additionalproperties>: (k :kw) -> (v :bool) = @{ @v = (@k == LXKW_ADDITIONALPROPERTIES); @};
	<kw-dependencies>:         (k :kw) -> (v :bool) = @{ @v = (@k == LXKW_DEPENDENCIES);         @};
	<kw-propertynames>:        (k :kw) -> (v :bool) = @{ @v = (@k == LXKW_PROPERTYNAMES);        @};

	<kw-enum>:                 (k :kw) -> (v :bool) = @{ @v = (@k == LXKW_ENUM);                 @};
	<kw-const>:                (k :kw) -> (v :bool) = @{ @v = (@k == LXKW_CONST);                @};
	<kw-type>:                 (k :kw) -> (v :bool) = @{ @v = (@k == LXKW_TYPE);                 @};
	<kw-allof>:                (k :kw) -> (v :bool) = @{ @v = (@k == LXKW_ALLOF);                @};
	<kw-anyof>:                (k :kw) -> (v :bool) = @{ @v = (@k == LXKW_ANYOF);                @};
	<kw-oneof>:                (k :kw) -> (v :bool) = @{ @v = (@k == LXKW_ONEOF);                @};
	<kw-not>:                  (k :kw) -> (v :bool) = @{ @v = (@k == LXKW_NOT);                  @};

	<kw-definitions>:          (k :kw) -> (v :bool) = @{ @v = (@k == LXKW_DEFINITIONS);          @};
	<kw-description>:          (k :kw) -> (v :bool) = @{ @v = (@k == LXKW_DESCRIPTION);          @};
	<kw-default>:              (k :kw) -> (v :bool) = @{ @v = (@k == LXKW_DEFAULT);              @};
	<kw-examples>:             (k :kw) -> (v :bool) = @{ @v = (@k == LXKW_EXAMPLES);             @};

	<set-schema>: (s :string) -> () = @{
		assert(@s.s != NULL);

		ast->schema = @s;
	@};

	<set-id>: (s :string) -> () = @{
		assert(@s.s != NULL);

		ast->id = @s;
	@};

	<set-multipleof>: (n :number) -> () = @{
		if (!(@n > 0)) {
			fprintf(stderr, "multipleOf: expected > 0, got %f\n", @n);
			@!;
		}

		ast->kw |= KW_MULTIPLE_OF;
		ast->multiple_of = @n;
	@};

	<set-maximum>: (n :number) -> () = @{
		ast->kw |= KW_MAXIMUM;
		ast->maximum = @n;
	@};

	<clear-types> = @{
		ast->types = 0;
	@};

	<set-type>: (t :type) -> () = @{
		switch (@t) {
		case JSON_VALUE_OBJECT:
		case JSON_VALUE_ARRAY:
		case JSON_VALUE_STRING:
		case JSON_VALUE_NUMBER:
		case JSON_VALUE_INTEGER:
		case JSON_VALUE_BOOL:
		case JSON_VAlUE_NULL:
			break;

		default:
			fprintf(stderr, "Type must be one of: "
				"\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\" or \"integer\"\n");
			@!;
		}

		if ((ast->types & @t)) {
			/* TODO: quote C&V for errors */
			fprintf(stderr, "Duplicate type; type names must be unique\n");
			@!;
		}

		ast->types |= @t;
	@};

%trailer% @{

	void
	parse(json_stream *lex_state, struct ast_schema *ast)
	{
		struct act_state a, *act_state = &a;

		assert(lex_state != NULL);
		assert(ast != NULL);

		ADVANCE_LEXER;

		p_file(lex_state, act_state, ast);
	}

@}, @{

	void
	parse(json_stream *json, struct ast_schema *ast);

@};

