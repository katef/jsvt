/*
 * Copyright 2017 Katherine Flavel
 *
 * See LICENCE for the full copyright terms.
 */

%prefixes%

	terminal = JSON_;
	function = p_;

%persistents%

	lex_state :lex_state;
	act_state :act_state;

%maps%

	string -> string;
	number -> double;
	bool   -> int;

%header% @{

	#define _POSIX_C_SOURCE 200809L

	#include <assert.h>
	#include <stdlib.h>
	#include <string.h>

	#include "json.h"
	#include "parser.h"
	#include "jdom.h"
	#include "ast.h"

	struct act_state {
		enum json_type t;
		enum json_type save;
		union {
			struct json_string str;
			json_number n;
		} u;
	};

	typedef struct json_string string;

	#define true  1
	#define false 0

	#define JSON_ARRAY__END  JSON_ARRAY_END
	#define JSON_OBJECT__END JSON_OBJECT_END

	#define CURRENT_TERMINAL act_state->t
	#define ERROR_TERMINAL   JSON_ERROR
	#define ADVANCE_LEXER    act_state->t = json_next(lex_state)
	#define SAVE_LEXER(t)    act_state->save = (t)
	#define RESTORE_LEXER    act_state->t = act_state->save

	char *
	xstrndup(const char *s, size_t n)
	{
		char *new;

		new = strndup(s, n);
		if (new == NULL) {
			perror("xstrndup");
			abort();
		}

		return new;
	}

@}, @{

	#include <stdio.h>

	#include "json.h"

	typedef struct act_state * act_state;
	typedef json_stream * lex_state;

	void
	parse(json_stream *json);

@};

%terminals%

	STRING: () -> (s :string) = @{
		assert(act_state->t == JSON_STRING);

		@s.s = json_get_string(lex_state, &@s.len);
		if (@s.s == NULL) {
			perror("json_get_string");
			exit(1);
		}

		@s.s = xstrndup(@s.s, @s.len);
	@};

	NUMBER: () -> (n :number) = @{
		assert(act_state->t == JSON_NUMBER);

		@n = json_get_number(lex_state);
	@};

	TRUE: () -> (v :bool) = @{
		@v = true;
	@};

	FALSE: () -> (v :bool) = @{
		@v = false;
	@};

%actions%

%trailer% @{

	void
	parse(json_stream *lex_state)
	{
		struct act_state a, *act_state = &a;

		assert(lex_state != NULL);

		ADVANCE_LEXER;

		p_file(lex_state, act_state);
	}

@}, @{

@};

