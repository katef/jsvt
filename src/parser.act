/*
 * Copyright 2017 Katherine Flavel
 *
 * See LICENCE for the full copyright terms.
 */

%prefixes%

	terminal = SJP_TOK_;
	function = p_;

%persistents%

	lex_state :lex_state;
	act_state :act_state;
	ast       :ast;

%maps%

	string -> string;
	number -> number;
	bool   -> bool;

	kw     -> kw;
	type   -> type;

%header% @{

	#include <assert.h>
	#include <stdarg.h>
	#include <stdlib.h>
	#include <string.h>

	#include "sjp_lexer.h"
	#include "parser.h"
	#include "jdom.h"
	#include "ast.h"
	#include "kw.h"
	#include "xalloc.h"

	struct act_state {
		struct sjp_token t;
		enum SJP_TOKEN save;
	};

	typedef struct json_string string;
	typedef json_number number;
	typedef enum kw kw;
	typedef enum json_valuetype type;

	#define CURRENT_TERMINAL act_state->t.type
	#define ERROR_TERMINAL   SJP_TOK_NONE /* XXX: NONE is not an error */
	#define ADVANCE_LEXER    next(lex_state, &act_state->t)
	#define SAVE_LEXER(type) act_state->save = (type)
	#define RESTORE_LEXER    act_state->t.type = act_state->save

	static void
	xerr(struct sjp_lexer *lex_state, enum kw k, const char *fmt, ...)
	{
		va_list ap;

		assert(lex_state != NULL);

		/* XXX: one token ahead */
		fprintf(stderr, "%zu: ", lex_state->line);

		if (k != 0) {
			fprintf(stderr, "\"%s\": ", kw_name(k));
		}

		va_start(ap, fmt);
		vfprintf(stderr, fmt, ap);
		va_end(ap);

		fprintf(stderr, "\n");

		exit(1);
	}

	static void
	xerr_syntax(struct sjp_lexer *lex_state, const char *name)
	{
		assert(lex_state != NULL);

		if (name == NULL) {
			xerr(lex_state, 0, "Syntax error");
		} else {
			xerr(lex_state, 0, "Syntax error: expected %s", name);
		}
	}

	static void
	next(struct sjp_lexer *lex_state, struct sjp_token *t)
	{
		int r;

		assert(lex_state != NULL);
		assert(t != NULL);

		r = sjp_lexer_token(lex_state, t);
		if (SJP_ERROR(r)) {
			xerr(lex_state, 0, "sjp error: %d, n=%zu", r, t->n);
			exit(EXIT_FAILURE);
		}
	}

@}, @{

	#include <stdio.h>

	#include "sjp_lexer.h"

	typedef struct ast_schema * ast;
	typedef struct act_state * act_state;
	typedef struct sjp_lexer * lex_state;

@};

%terminals%

	STRING: () -> (s :string) = @{
		assert(act_state->t.type == @$STRING);

		@s.s   = xstrndup(act_state->t.value, act_state->t.n);
		@s.len = act_state->t.n;
	@};

	NUMBER: () -> (n :number) = @{
		assert(act_state->t.type == @$NUMBER);

		@n = act_state->t.dbl;
	@};

	TRUE: () -> (v :bool) = @{
		@v = true;
	@};

	FALSE: () -> (v :bool) = @{
		@v = false;
	@};

%actions%

	<kw-lookup>: (s :string) -> (k :kw) = @{
		@k = kw_lookup(&@s);
		if (@k == 0) {
			xerr(lex_state, 0, "Unrecognised keyword: \"%s\"", @s.s);
			@!;
		}
	@};

	<type-lookup>: (s :string) -> (t :type) = @{
		@t = type_lookup(&@s);
		if (@t == 0) {
			xerr(lex_state, KW_TYPE, "Unknown type name: \"%s\"", @s.s);
		}
	@};

	<kw-schema>:               (k :kw) -> (v :bool) = @{ @v = (@k == KW_SCHEMA);                @};
	<kw-ref>:                  (k :kw) -> (v :bool) = @{ @v = (@k == KW_REF);                   @};
	<kw-id>:                   (k :kw) -> (v :bool) = @{ @v = (@k == KW_ID);                    @};

	<kw-multipleof>:           (k :kw) -> (v :bool) = @{ @v = (@k == KW_MULTIPLE_OF);           @};
	<kw-maximum>:              (k :kw) -> (v :bool) = @{ @v = (@k == KW_MAXIMUM);               @};
	<kw-exclusivemaximum>:     (k :kw) -> (v :bool) = @{ @v = (@k == KW_EXCLUSIVE_MAXIMUM);     @};
	<kw-minimum>:              (k :kw) -> (v :bool) = @{ @v = (@k == KW_MINIMUM);               @};
	<kw-exclusiveminimum>:     (k :kw) -> (v :bool) = @{ @v = (@k == KW_EXCLUSIVE_MINIMUM);     @};
	<kw-maxlength>:            (k :kw) -> (v :bool) = @{ @v = (@k == KW_MAX_LENGTH);            @};
	<kw-minlength>:            (k :kw) -> (v :bool) = @{ @v = (@k == KW_MIN_LENGTH);            @};
	<kw-pattern>:              (k :kw) -> (v :bool) = @{ @v = (@k == KW_PATTERN);               @};
	<kw-items>:                (k :kw) -> (v :bool) = @{ @v = (@k == KW_ITEMS);                 @};
	<kw-additionalitems>:      (k :kw) -> (v :bool) = @{ @v = (@k == KW_ADDITIONAL_ITEMS);      @};
	<kw-maxitems>:             (k :kw) -> (v :bool) = @{ @v = (@k == KW_MAX_ITEMS);             @};
	<kw-minitems>:             (k :kw) -> (v :bool) = @{ @v = (@k == KW_MIN_ITEMS);             @};
	<kw-uniqueitems>:          (k :kw) -> (v :bool) = @{ @v = (@k == KW_UNIQUE_ITEMS);          @};
	<kw-contains>:             (k :kw) -> (v :bool) = @{ @v = (@k == KW_CONTAINS);              @};
	<kw-maxproperties>:        (k :kw) -> (v :bool) = @{ @v = (@k == KW_MAX_PROPERTIES);        @};
	<kw-minproperties>:        (k :kw) -> (v :bool) = @{ @v = (@k == KW_MIN_PROPERTIES);        @};
	<kw-required>:             (k :kw) -> (v :bool) = @{ @v = (@k == KW_REQUIRED);              @};
	<kw-properties>:           (k :kw) -> (v :bool) = @{ @v = (@k == KW_PROPERTIES);            @};
	<kw-patternproperties>:    (k :kw) -> (v :bool) = @{ @v = (@k == KW_PATTERN_PROPERTIES);    @};
	<kw-additionalproperties>: (k :kw) -> (v :bool) = @{ @v = (@k == KW_ADDITIONAL_PROPERTIES); @};
	<kw-dependencies>:         (k :kw) -> (v :bool) = @{ @v = (@k == KW_DEPENDENCIES);          @};
	<kw-propertynames>:        (k :kw) -> (v :bool) = @{ @v = (@k == KW_PROPERTY_NAMES);        @};

	<kw-enum>:                 (k :kw) -> (v :bool) = @{ @v = (@k == KW_ENUM);                  @};
	<kw-const>:                (k :kw) -> (v :bool) = @{ @v = (@k == KW_CONST);                 @};
	<kw-type>:                 (k :kw) -> (v :bool) = @{ @v = (@k == KW_TYPE);                  @};
	<kw-allof>:                (k :kw) -> (v :bool) = @{ @v = (@k == KW_ALL_OF);                @};
	<kw-anyof>:                (k :kw) -> (v :bool) = @{ @v = (@k == KW_ANY_OF);                @};
	<kw-oneof>:                (k :kw) -> (v :bool) = @{ @v = (@k == KW_ONE_OF);                @};
	<kw-not>:                  (k :kw) -> (v :bool) = @{ @v = (@k == KW_NOT);                   @};

	<kw-definitions>:          (k :kw) -> (v :bool) = @{ @v = (@k == KW_DEFINITIONS);           @};
	<kw-description>:          (k :kw) -> (v :bool) = @{ @v = (@k == KW_DESCRIPTION);           @};
	<kw-default>:              (k :kw) -> (v :bool) = @{ @v = (@k == KW_DEFAULT);               @};
	<kw-examples>:             (k :kw) -> (v :bool) = @{ @v = (@k == KW_EXAMPLES);              @};

	<set-schema>: (s :string) -> () = @{
		assert(@s.s != NULL);

		ast->schema = @s;
	@};

	<set-id>: (s :string) -> () = @{
		assert(@s.s != NULL);

		ast->id = @s;
	@};

	<set-multipleof>: (n :number) -> () = @{
		if (!(@n > 0)) {
			xerr(lex_state, KW_MULTIPLE_OF, "expected > 0, got %f", @n);
		}

		ast->kws |= KWS_MULTIPLE_OF;
		ast->multiple_of = @n;
	@};

	<set-maximum>: (n :number) -> () = @{
		ast->kws |= KWS_MAXIMUM;
		ast->maximum = @n;
	@};

	<clear-types> = @{
		ast->types = 0;
	@};

	<set-type>: (t :type) -> () = @{
		switch (@t) {
		case JSON_VALUE_OBJECT:
		case JSON_VALUE_ARRAY:
		case JSON_VALUE_STRING:
		case JSON_VALUE_NUMBER:
		case JSON_VALUE_INTEGER:
		case JSON_VALUE_BOOL:
		case JSON_VALUE_NULL:
			break;

		default:
			xerr(lex_state, KW_TYPE, "Type must be one of: "
				"\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\" or \"integer\"");
		}

		if ((ast->types & @t)) {
			/* TODO: quote C&V for errors */
			xerr(lex_state, KW_TYPE, "Duplicate type; type names must be unique");
		}

		ast->types |= @t;
	@};

	<err-unimplemented> = @{
		xerr(lex_state, 0, "unimplemented");
	@};

	<err-syntax> = @{
		xerr_syntax(lex_state, NULL);
	@};

	<err-expected-directive> = @{
		xerr_syntax(lex_state, "keyword directive");
	@};

	<err-expected-schema> = @{
		xerr_syntax(lex_state, "schema");
	@};

%trailer% @{

	void
	parse(struct sjp_lexer *lex_state, struct ast_schema *ast)
	{
		struct act_state a, *act_state = &a;

		assert(lex_state != NULL);
		assert(ast != NULL);

		ADVANCE_LEXER;

		p_file(lex_state, act_state, ast);
	}

@}, @{

	void
	parse(struct sjp_lexer *lex_state, struct ast_schema *ast);

@};

